The main design of this refactor is to break down the single-file implementation (main.py) into a modular structure with a clear separation of responsibilities. The system is divided into several main components: the rag folder for RAG workflows and state contracts; stores for document storage and retrieval through consistent abstractions; and services as a business logic layer between the API and technical components. The API and configuration are separated into dedicated modules so that endpoints remain thin and configuration values are not hardcoded. All dependencies are made explicit using dependency injection, and system initialization is moved to the FastAPI startup lifecycle to avoid the use of global state and side effects during import.

This refactor also directly corrects various design issues from the initial version. The recreate_collection() process in Qdrant, which previously deleted data every startup, has been replaced with a safer initialization. The Fake Embedding, which previously relied on Python's hash() (unstable across processes), has been fixed to be deterministic using stable hashing. The memory storage fallback mechanism, which originally only performed substring matching, now uses cosine similarity-based search to remain consistent with vector search. Furthermore, unsafe document ID assignment has been replaced with UUIDs, LangGraph workflows now have clear state contracts, and API error handling has been clarified by differentiating status codes such as 400, 503, and 500.

One trade-off consciously taken is to continue using hashing-based embeddings and local random generation, rather than actual AI models like OpenAI or HuggingFace. This decision was made because the primary focus of the technical test is code design quality and dependency management, not the performance or accuracy of the AI model. This refactored version increases maintainability by making the codebase easier to understand, modify, and extend. Each component has one clear responsibility, configuration is centralized, and implicit dependencies are eliminated. As a result, future changesâ€”such as adding tests, replacing the storage backend, or modifying the RAG workflow can be implemented with minimal impact on other unrelated parts of the system.
